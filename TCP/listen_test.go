package TCP

import (
	"net"
	"testing"
)

func TestListener(t *testing.T) {
	// 리스너 생성

	/* net.Listen 함수
	net.Listen 함수는 매개변수로 네트워크 종류와 콜론으로 구분된 IP 주소와 포트 문자열을 받는다.
	실습 코드에서는 네트워크 종류는 tcp 로 설정해주고, 주소는 루프백 주소, 포트는 0으로 주었다.
	포트가 0이거나 비워져있으면 Go가 리스너에 사용가능한 무작위 포트 번호를 할당한다.
	IP 주소를 생략하면 리스너는 시스템상의 모든 유니캐스트와 애니캐스트 IP 주소에 바인딩된다.
	반환 값으로 net.Listener 인터페이스와 에러 인터페이스를 반환한다.
	이미 바인딩된 포트에 리스너가 바인딩을 시도하는 경우 net.Listen 함수는 에러를 반환한다.
	*/
	listener, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatal(err)
	}

	/*
		Close 메서드를 사용하여 항상 리스너를 graceful close 해준다.
		리스너를 종료하는 데 실패하면 메모리 누수가 발생하거나
		코드상에서 리스너의 Accept 메서드가 무한정 블로킹되며 deadlock 이 발생 할 수 있다.
	*/
	defer func() { _ = listener.Close() }()

	// Addr 리스너를 아용하여 리스너의 주소를 얻어 올 수 있다.
	t.Logf("bound to %q", listener.Addr())
	// 리스너가 TCP 의 수신 연결 요청을 수락하는 과정
	/*
		하나 이상의 수신 연결을 처리하기 위해서는 for 루프를 사용하여 서버가 계속해서 수신 연결 요청을 수락하고,
		goroutine 에서 해당 연결을 처리하고, 다시 for 루프로 돌아와서 다음 연결 요청을 수락할 수 있도록 대기해야 한다.
	*/
	/* 코드
	for {
		// 리스너의 Accept() 메서드는 수신 연결을 감지하고 클라이언트와 서버 간의 TCP 루프의 처음을 시작한다.
		// 이 메서드는 리스너가 수신 연결을 감지하고 클라이언트와 서버 간의 TCP 핸드셰이크 절차가 완료될 때까지 블로킹된다.
		// 메서드는 net.Conn 인터페이스와 에러를 반환한다, 가령 TCP 핸드셰이크가 실패하거나 리스너가 닫힌 경우 에러 인터페이스의 값이 nil 외의 값을 갖게 된다.
	 	// 현재 예시에서는 TCP 수신 연결을 수락했기 때문에 net.TCPConn 객체의 포인터가 된다. 연결 인터페이스는 서버 측면에서의 TCP 연결을 나타낸다.
		// net.TCPConn 객체는 net.Conn 인터페이스에서 제공하는 것보다 더 많은 기능을 제공해 세밀한 제어가 가능하다.
		conn, err := listener.Accept()
		if err != nil {
			return err
		}

		// 클라이언트의 연결을 동시에 처리하기 위해 고루틴을 사용해 각 연결을 비동기적으로 처리하도록 하여 리스너가 다음 수신 연결을 처리할 수 있도록 한다.
		//고루틴을 사용하지 않고 코드를 작성하여 처리하는것도 가능은 하지만, Go 언어의 장점을 살리지 못해 비효율적이다.
		go func(c net.Conn) {
			// 연결 객체의 close 메서드를 호출하여 고루틴이 종료되기 전에 호출하여 서버로 FIN 패킷을 보내 연결이 graceful close 될 수 있도록 해준다.
			defer c.Close()
			// TCP 연결을 사용하여 비즈니스 로직을 작성
		}(conn)
	}
	*/
}
